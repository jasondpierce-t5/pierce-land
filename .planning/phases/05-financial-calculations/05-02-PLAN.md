---
phase: 05-financial-calculations
plan: 02
type: execute
depends_on: ["05-01"]
files_modified: [src/lib/calculations.ts, src/lib/types.ts]
---

<objective>
Implement core calculation logic for stocker cattle financial projections including spring turn, winter turn, and annual summaries.

Purpose: Create reusable calculation functions that transform config data into financial projections, following formulas documented in project.md
Output: Calculation engine (calculations.ts) with mergeConfig, calculateSpringTurn, calculateWinterTurn, and calculateAnnualProjections functions
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-financial-calculations/05-01-SUMMARY.md
@project.md
@src/lib/utils.ts

**Tech stack available:**
- TypeScript for type safety and calculation logic
- Numeric type from database ensures precision
- Next.js server components can use calculations server-side

**Established patterns:**
- Utility functions in src/lib/ (generateSlug in utils.ts from Phase 4)
- Type definitions in separate types.ts file
- Numeric precision for all financial calculations

**Constraining decisions from Plan 05-01:**
- Expanded plan_config schema with 46 fields
- Nullable override pattern in plan_versions (null = use config default)
- Spring/winter turn parameters are separate in schema
- All costs are per-head basis

**Calculation formulas from project.md:**

**mergeConfig:**
```typescript
// Apply plan_version overrides to plan_config
// If override is null, use config value
// Returns complete config with all values resolved
```

**Spring Turn:**
```typescript
purchaseCost = purchase_weight_lbs × (market_price_500lb / 100)  // price is per cwt
weightGain = spring_sale_weight_lbs - purchase_weight_lbs
daysOnFeed = spring_days_on_feed
interestCost = purchaseCost × (interest_rate_pct / 100) × (daysOnFeed / 365)
deathLoss = purchaseCost × (spring_death_loss_pct / 100)
carryingCosts = spring_health_cost_per_head + spring_freight_in_per_head +
                spring_mineral_cost_per_head + spring_lrp_premium_per_head +
                spring_marketing_commission_per_head + spring_freight_out_per_head +
                interestCost + deathLoss + spring_misc_per_head
totalInvestment = purchaseCost + carryingCosts
grossRevenue = spring_sale_weight_lbs × (market_price_850lb / 100)  // mid scenario
netIncome = grossRevenue - totalInvestment
costOfGain = carryingCosts / weightGain
```

**Winter Turn (additional feed costs):**
```typescript
// Same base calculation as spring, but add:
hayPricePerLb = hay_price_per_bale / hay_bale_weight_lbs
hayConsumed = hay_daily_intake_lbs × winter_days_on_feed
hayCost = hayConsumed × hayPricePerLb
hayWaste = hayCost × (hay_waste_pct / 100)
commodityCost = commodity_daily_intake_lbs × winter_days_on_feed × (commodity_price_per_ton / 2000)
totalFeedCost = hayCost + hayWaste + commodityCost
carryingCosts = winter_* costs + totalFeedCost  // winter costs include feed
```

**Annual Projections:**
```typescript
// Sum spring + winter with head_count multiplier
totalNetIncome = (springNet × head_count) + (winterNet × head_count)
totalRevenue = springRevenue + winterRevenue (both × head_count)
totalInvestment = springInvestment + winterInvestment (both × head_count)
// Account for LOC usage and capacity
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create type definitions and mergeConfig utility</name>
  <files>src/lib/types.ts, src/lib/calculations.ts</files>
  <action>
Create type definitions in src/lib/types.ts for the expanded schema and calculation results.

**Types to define:**

```typescript
// Database types (matching expanded schema)
export interface PlanConfig {
  id: string;
  created_at: string;
  updated_at: string;

  // Operator (4 fields)
  operator_name: string;
  operation_location: string;
  acres: number;
  years_experience: number;

  // Market prices (4 fields - 2 existing + 2 scenarios)
  market_price_500lb: number;  // existing - base/mid price
  market_price_850lb: number;  // existing - base/mid price
  sale_price_low_per_cwt: number;
  sale_price_high_per_cwt: number;

  // Feed costs (2 existing)
  hay_price_per_ton: number;
  feed_cost_per_day: number;

  // Operational (4 existing)
  purchase_weight_lbs: number;
  sale_weight_lbs: number;
  avg_daily_gain_lbs: number;
  mortality_rate_pct: number;

  // Spring turn (10 new)
  spring_sale_weight_lbs: number;
  spring_days_on_feed: number;
  spring_health_cost_per_head: number;
  spring_freight_in_per_head: number;
  spring_mineral_cost_per_head: number;
  spring_lrp_premium_per_head: number;
  spring_marketing_commission_per_head: number;
  spring_freight_out_per_head: number;
  spring_death_loss_pct: number;
  spring_misc_per_head: number;

  // Winter turn (10 new)
  winter_sale_weight_lbs: number;
  winter_days_on_feed: number;
  winter_health_cost_per_head: number;
  winter_freight_in_per_head: number;
  winter_mineral_cost_per_head: number;
  winter_lrp_premium_per_head: number;
  winter_marketing_commission_per_head: number;
  winter_freight_out_per_head: number;
  winter_death_loss_pct: number;
  winter_misc_per_head: number;

  // Winter feed (6 new)
  hay_price_per_bale: number;
  hay_bale_weight_lbs: number;
  hay_daily_intake_lbs: number;
  hay_waste_pct: number;
  commodity_price_per_ton: number;
  commodity_daily_intake_lbs: number;

  // Financial defaults (3 existing)
  interest_rate_pct: number;
  loc_amount: number;
  head_count: number;
}

export interface PlanVersion {
  id: string;
  created_at: string;
  updated_at: string;
  slug: string;
  bank_name: string;
  is_active: boolean;
  override_loc_amount: number | null;
  override_interest_rate_pct: number | null;
  override_head_count: number | null;
}

// Calculation result types
export interface TurnResult {
  purchaseCost: number;
  weightGain: number;
  daysOnFeed: number;
  interestCost: number;
  deathLoss: number;
  carryingCosts: number;
  totalInvestment: number;
  grossRevenue: number;
  netIncome: number;
  costOfGain: number;
}

export interface WinterTurnResult extends TurnResult {
  hayPricePerLb: number;
  hayConsumed: number;
  hayCost: number;
  hayWaste: number;
  commodityCost: number;
  totalFeedCost: number;
}

export interface AnnualProjection {
  springTotal: number;
  winterTotal: number;
  annualNetIncome: number;
  totalRevenue: number;
  totalInvestment: number;
  locUtilization: number;
  locCapacityRemaining: number;
}
```

**Create calculations.ts with mergeConfig function:**

```typescript
import type { PlanConfig, PlanVersion } from './types';

/**
 * Merges plan_config with plan_version overrides.
 * If override is null or undefined, uses config value.
 * Returns config with all values resolved.
 */
export function mergeConfig(
  config: PlanConfig,
  version?: PlanVersion | null
): PlanConfig {
  if (!version) return config;

  return {
    ...config,
    loc_amount: version.override_loc_amount ?? config.loc_amount,
    interest_rate_pct: version.override_interest_rate_pct ?? config.interest_rate_pct,
    head_count: version.override_head_count ?? config.head_count,
  };
}
```

**What to avoid:**
- Don't use JavaScript number for currency (rely on database numeric, but TypeScript number is fine for calculations)
- Don't mutate input objects (return new objects with spread operator)
- Don't skip null checking for override fields (use nullish coalescing ??)
  </action>
  <verify>
TypeScript compiles with no errors.
All types match the expanded schema from Plan 05-01.
mergeConfig correctly applies overrides with null fallback.
  </verify>
  <done>
src/lib/types.ts created with PlanConfig, PlanVersion, TurnResult, WinterTurnResult, AnnualProjection interfaces.
src/lib/calculations.ts created with mergeConfig function.
TypeScript compilation succeeds, types are accurate and complete.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement spring and winter turn calculation functions</name>
  <files>src/lib/calculations.ts</files>
  <action>
Add calculateSpringTurn and calculateWinterTurn functions to calculations.ts following the formulas from project.md.

**calculateSpringTurn implementation:**

```typescript
export function calculateSpringTurn(config: PlanConfig): TurnResult {
  // Purchase cost (price is per cwt, so divide by 100)
  const purchaseCost = config.purchase_weight_lbs * (config.market_price_500lb / 100);

  // Weight gain
  const weightGain = config.spring_sale_weight_lbs - config.purchase_weight_lbs;

  // Days on feed
  const daysOnFeed = config.spring_days_on_feed;

  // Interest cost (annualized)
  const interestCost = purchaseCost * (config.interest_rate_pct / 100) * (daysOnFeed / 365);

  // Death loss
  const deathLoss = purchaseCost * (config.spring_death_loss_pct / 100);

  // Sum all carrying costs
  const carryingCosts =
    config.spring_health_cost_per_head +
    config.spring_freight_in_per_head +
    config.spring_mineral_cost_per_head +
    config.spring_lrp_premium_per_head +
    config.spring_marketing_commission_per_head +
    config.spring_freight_out_per_head +
    interestCost +
    deathLoss +
    config.spring_misc_per_head;

  // Total investment
  const totalInvestment = purchaseCost + carryingCosts;

  // Gross revenue (sale weight × mid price per cwt)
  const grossRevenue = config.spring_sale_weight_lbs * (config.market_price_850lb / 100);

  // Net income
  const netIncome = grossRevenue - totalInvestment;

  // Cost of gain
  const costOfGain = weightGain > 0 ? carryingCosts / weightGain : 0;

  return {
    purchaseCost,
    weightGain,
    daysOnFeed,
    interestCost,
    deathLoss,
    carryingCosts,
    totalInvestment,
    grossRevenue,
    netIncome,
    costOfGain,
  };
}
```

**calculateWinterTurn implementation:**

```typescript
export function calculateWinterTurn(config: PlanConfig): WinterTurnResult {
  // Purchase cost (same as spring)
  const purchaseCost = config.purchase_weight_lbs * (config.market_price_500lb / 100);

  // Weight gain (winter uses winter_sale_weight)
  const weightGain = config.winter_sale_weight_lbs - config.purchase_weight_lbs;

  // Days on feed (winter)
  const daysOnFeed = config.winter_days_on_feed;

  // Interest cost
  const interestCost = purchaseCost * (config.interest_rate_pct / 100) * (daysOnFeed / 365);

  // Death loss (winter rate)
  const deathLoss = purchaseCost * (config.winter_death_loss_pct / 100);

  // Feed costs (winter-specific)
  const hayPricePerLb = config.hay_price_per_bale / config.hay_bale_weight_lbs;
  const hayConsumed = config.hay_daily_intake_lbs * daysOnFeed;
  const hayCost = hayConsumed * hayPricePerLb;
  const hayWaste = hayCost * (config.hay_waste_pct / 100);
  const commodityCost = config.commodity_daily_intake_lbs * daysOnFeed * (config.commodity_price_per_ton / 2000);
  const totalFeedCost = hayCost + hayWaste + commodityCost;

  // Sum all carrying costs (winter operations + feed)
  const carryingCosts =
    config.winter_health_cost_per_head +
    config.winter_freight_in_per_head +
    config.winter_mineral_cost_per_head +
    config.winter_lrp_premium_per_head +
    config.winter_marketing_commission_per_head +
    config.winter_freight_out_per_head +
    interestCost +
    deathLoss +
    config.winter_misc_per_head +
    totalFeedCost;

  // Total investment
  const totalInvestment = purchaseCost + carryingCosts;

  // Gross revenue (winter sale weight × mid price)
  const grossRevenue = config.winter_sale_weight_lbs * (config.market_price_850lb / 100);

  // Net income
  const netIncome = grossRevenue - totalInvestment;

  // Cost of gain
  const costOfGain = weightGain > 0 ? carryingCosts / weightGain : 0;

  return {
    purchaseCost,
    weightGain,
    daysOnFeed,
    interestCost,
    deathLoss,
    carryingCosts,
    totalInvestment,
    grossRevenue,
    netIncome,
    costOfGain,
    // Winter-specific
    hayPricePerLb,
    hayConsumed,
    hayCost,
    hayWaste,
    commodityCost,
    totalFeedCost,
  };
}
```

**What to avoid:**
- Don't round intermediate calculations (keep full precision until display)
- Don't use cwt prices directly without dividing by 100 (prices are per 100 lbs)
- Don't skip division-by-zero checks (costOfGain when weightGain = 0)
- Don't hardcode any operational costs (all must come from config)
  </action>
  <verify>
TypeScript compiles with no errors.
Spring turn calculation returns all expected fields.
Winter turn calculation includes feed cost breakdown.
Unit test with sample config values produces expected results (manual verification with calculator).
  </verify>
  <done>
calculateSpringTurn implemented with all cost components.
calculateWinterTurn implemented with feed cost breakdown.
Both functions return properly typed results.
Calculations follow project.md formulas exactly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement annual projections and breakeven calculations</name>
  <files>src/lib/calculations.ts</files>
  <action>
Add calculateAnnualProjections and calculateBreakeven helper functions.

**calculateAnnualProjections implementation:**

```typescript
export function calculateAnnualProjections(
  spring: TurnResult,
  winter: WinterTurnResult,
  config: PlanConfig
): AnnualProjection {
  const headCount = config.head_count;

  // Total net income (spring + winter) × head count
  const springTotal = spring.netIncome * headCount;
  const winterTotal = winter.netIncome * headCount;
  const annualNetIncome = springTotal + winterTotal;

  // Total revenue
  const totalRevenue = (spring.grossRevenue * headCount) + (winter.grossRevenue * headCount);

  // Total investment
  const totalInvestment = (spring.totalInvestment * headCount) + (winter.totalInvestment * headCount);

  // LOC utilization
  const locUtilization = (totalInvestment / config.loc_amount) * 100;
  const locCapacityRemaining = config.loc_amount - totalInvestment;

  return {
    springTotal,
    winterTotal,
    annualNetIncome,
    totalRevenue,
    totalInvestment,
    locUtilization,
    locCapacityRemaining,
  };
}
```

**calculateBreakeven helper:**

```typescript
/**
 * Calculate breakeven sale price per cwt for a turn.
 * Breakeven is the price where netIncome = 0.
 */
export function calculateBreakeven(
  totalInvestment: number,
  saleWeightLbs: number
): number {
  // breakeven_price_per_cwt = (totalInvestment / saleWeightLbs) * 100
  return saleWeightLbs > 0 ? (totalInvestment / saleWeightLbs) * 100 : 0;
}

/**
 * Get breakeven prices for both turns.
 */
export function getBreakevenPrices(
  spring: TurnResult,
  winter: WinterTurnResult,
  config: PlanConfig
) {
  return {
    springBreakeven: calculateBreakeven(spring.totalInvestment, config.spring_sale_weight_lbs),
    winterBreakeven: calculateBreakeven(winter.totalInvestment, config.winter_sale_weight_lbs),
  };
}
```

**Export all functions:**

```typescript
// At top of file
export {
  mergeConfig,
  calculateSpringTurn,
  calculateWinterTurn,
  calculateAnnualProjections,
  calculateBreakeven,
  getBreakevenPrices,
};
```

**What to avoid:**
- Don't calculate breakeven incorrectly (totalInvestment / saleWeight × 100 to get per cwt)
- Don't skip division-by-zero guards (saleWeight could theoretically be 0)
- Don't mutate input objects (all functions are pure)
- Don't add rounding at calculation level (consumers decide display precision)
  </action>
  <verify>
All functions compile without TypeScript errors.
calculateAnnualProjections correctly sums spring + winter with head_count multiplier.
Breakeven calculation returns price in per-cwt format (matches market_price fields).
All exports are present and usable from other modules.
  </verify>
  <done>
calculateAnnualProjections implemented with LOC utilization tracking.
Breakeven helper functions created for both turns.
All calculation functions exported and ready for use in Plan 05-03 and Plan 06 (public pages).
Core calculation engine complete and typed.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compilation succeeds with no errors
- [ ] All type definitions match expanded schema
- [ ] mergeConfig correctly applies nullable overrides
- [ ] calculateSpringTurn produces accurate results
- [ ] calculateWinterTurn includes feed cost breakdown
- [ ] calculateAnnualProjections sums correctly with head_count
- [ ] Breakeven calculations return per-cwt prices
- [ ] All functions are exported and importable
</verification>

<success_criteria>

- All tasks completed
- Type definitions created for all schema entities and calculation results
- mergeConfig utility handles override pattern correctly
- Spring turn calculations implemented per project.md formulas
- Winter turn calculations include feed cost breakdown
- Annual projections sum spring + winter with head count multiplier
- Breakeven helper functions created
- All functions are pure, typed, and tested
- Ready for Plan 05-03 (sensitivity analysis functions)
</success_criteria>

<output>
After completion, create `.planning/phases/05-financial-calculations/05-02-SUMMARY.md`:

# Phase 5 Plan 02: Calculation Engine Core Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `src/lib/types.ts` - Description
- `src/lib/calculations.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 05-03-PLAN.md (Scenario & Sensitivity Analysis)
</output>
