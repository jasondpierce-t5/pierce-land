---
phase: 05-financial-calculations
plan: 03
type: execute
depends_on: ["05-02"]
files_modified: [src/lib/calculations.ts]
---

<objective>
Implement scenario analysis and sensitivity analysis functions for business plan projections.

Purpose: Add functions that calculate low/mid/high price scenarios, hay price sensitivity ranges, and purchase price sensitivity ranges for comprehensive financial analysis
Output: Scenario and sensitivity functions in calculations.ts ready for chart generation in Phase 7
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-plan.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-financial-calculations/05-01-SUMMARY.md
@.planning/phases/05-financial-calculations/05-02-SUMMARY.md
@project.md
@src/lib/calculations.ts
@src/lib/types.ts

**Tech stack available:**
- Core calculation functions from Plan 05-02 (calculateSpringTurn, calculateWinterTurn, etc.)
- Type definitions for all results
- Expanded schema with scenario prices (sale_price_low_per_cwt, sale_price_high_per_cwt)

**Established patterns:**
- Pure functions that don't mutate inputs
- Typed return objects with all fields explicit
- Division-by-zero guards for safety

**Constraining decisions:**
- Scenarios use existing sale_price_low/high fields from schema
- Sensitivity ranges defined in project.md (hay $40-$80, purchase ±$0.20/lb)
- All calculations reuse core turn functions (don't duplicate logic)

**Requirements being addressed:**
From PROJECT.md:
- "Scenario analysis (low/mid/high prices)"
- "Hay price sensitivity, purchase price sensitivity"

From project.md:
- "Hay sensitivity: Loop hay price from $40 to $80 in $10 increments"
- "Purchase sensitivity: Loop purchase price from (base - $0.20) to (base + $0.20) in $0.10 increments"
- "Worst case: Max purchase price + min sale price"

**Calculation approach:**
- Scenarios: Recalculate turns with different sale prices (low/mid/high)
- Hay sensitivity: Recalculate winter turn with varying hay_price_per_bale
- Purchase sensitivity: Recalculate both turns with varying market_price_500lb
- Worst case: Combine highest costs with lowest revenue
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement scenario analysis with low/mid/high price projections</name>
  <files>src/lib/calculations.ts, src/lib/types.ts</files>
  <action>
Add scenario calculation functions that project outcomes at low, mid, and high sale prices.

**Add types to src/lib/types.ts:**

```typescript
export interface ScenarioResult {
  scenario: 'low' | 'mid' | 'high';
  salePriceCwt: number;
  springNet: number;
  winterNet: number;
  annualNet: number;
}

export interface ScenarioAnalysis {
  low: ScenarioResult;
  mid: ScenarioResult;
  high: ScenarioResult;
}
```

**Add to src/lib/calculations.ts:**

```typescript
/**
 * Calculate turn results at a specific sale price.
 * Creates modified config with custom sale price, then runs calculations.
 */
function calculateTurnAtPrice(
  config: PlanConfig,
  salePriceCwt: number,
  turnType: 'spring' | 'winter'
): TurnResult | WinterTurnResult {
  // Create modified config with custom sale price
  const modifiedConfig = {
    ...config,
    market_price_850lb: salePriceCwt,  // Override mid price with scenario price
  };

  return turnType === 'spring'
    ? calculateSpringTurn(modifiedConfig)
    : calculateWinterTurn(modifiedConfig);
}

/**
 * Calculate financial projections across low/mid/high price scenarios.
 */
export function calculateScenarios(config: PlanConfig): ScenarioAnalysis {
  const headCount = config.head_count;

  // Low scenario
  const springLow = calculateTurnAtPrice(config, config.sale_price_low_per_cwt, 'spring') as TurnResult;
  const winterLow = calculateTurnAtPrice(config, config.sale_price_low_per_cwt, 'winter') as WinterTurnResult;
  const lowAnnual = (springLow.netIncome * headCount) + (winterLow.netIncome * headCount);

  // Mid scenario (base case - uses market_price_850lb)
  const springMid = calculateSpringTurn(config);
  const winterMid = calculateWinterTurn(config);
  const midAnnual = (springMid.netIncome * headCount) + (winterMid.netIncome * headCount);

  // High scenario
  const springHigh = calculateTurnAtPrice(config, config.sale_price_high_per_cwt, 'spring') as TurnResult;
  const winterHigh = calculateTurnAtPrice(config, config.sale_price_high_per_cwt, 'winter') as WinterTurnResult;
  const highAnnual = (springHigh.netIncome * headCount) + (winterHigh.netIncome * headCount);

  return {
    low: {
      scenario: 'low',
      salePriceCwt: config.sale_price_low_per_cwt,
      springNet: springLow.netIncome,
      winterNet: winterLow.netIncome,
      annualNet: lowAnnual,
    },
    mid: {
      scenario: 'mid',
      salePriceCwt: config.market_price_850lb,
      springNet: springMid.netIncome,
      winterNet: winterMid.netIncome,
      annualNet: midAnnual,
    },
    high: {
      scenario: 'high',
      salePriceCwt: config.sale_price_high_per_cwt,
      springNet: springHigh.netIncome,
      winterNet: winterHigh.netIncome,
      annualNet: highAnnual,
    },
  };
}
```

**What to avoid:**
- Don't mutate the original config (create modified copies with spread operator)
- Don't recalculate scenarios every time (consumers can cache if needed)
- Don't skip any scenarios (all three must be present for chart generation)
- Don't hardcode sale prices (use schema fields: sale_price_low_per_cwt, market_price_850lb, sale_price_high_per_cwt)
  </action>
  <verify>
TypeScript compiles with no errors.
calculateScenarios returns low/mid/high results with correct structure.
Mid scenario matches baseline calculateSpringTurn/calculateWinterTurn results.
Low scenario shows lower net income, high shows higher net income (assuming positive margins).
  </verify>
  <done>
ScenarioResult and ScenarioAnalysis types added to types.ts.
calculateScenarios function implemented with low/mid/high projections.
Helper function calculateTurnAtPrice allows price variation.
All scenarios calculated using core turn functions (no logic duplication).
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement hay price sensitivity analysis</name>
  <files>src/lib/calculations.ts, src/lib/types.ts</files>
  <action>
Add hay price sensitivity function that shows how winter turn profitability changes across hay price range.

**Add types to src/lib/types.ts:**

```typescript
export interface HaySensitivityPoint {
  hayPricePerBale: number;
  totalFeedCost: number;
  winterNetPerHead: number;
  winterNetTotal: number;
}

export type HaySensitivityTable = HaySensitivityPoint[];
```

**Add to src/lib/calculations.ts:**

```typescript
/**
 * Calculate hay price sensitivity for winter turn.
 * Shows how winter profitability changes across hay price range.
 * Default range: $40 to $80 per bale in $10 increments (from project.md).
 */
export function calculateHaySensitivity(
  config: PlanConfig,
  minPrice: number = 40,
  maxPrice: number = 80,
  increment: number = 10
): HaySensitivityTable {
  const results: HaySensitivityTable = [];
  const headCount = config.head_count;

  for (let hayPrice = minPrice; hayPrice <= maxPrice; hayPrice += increment) {
    // Create modified config with custom hay price
    const modifiedConfig = {
      ...config,
      hay_price_per_bale: hayPrice,
    };

    // Recalculate winter turn with modified hay price
    const winterResult = calculateWinterTurn(modifiedConfig);

    results.push({
      hayPricePerBale: hayPrice,
      totalFeedCost: winterResult.totalFeedCost,
      winterNetPerHead: winterResult.netIncome,
      winterNetTotal: winterResult.netIncome * headCount,
    });
  }

  return results;
}
```

**What to avoid:**
- Don't skip any price points in the range (increment must be consistent)
- Don't mutate config (create modified copy for each iteration)
- Don't return unsorted results (loop naturally produces ascending order)
- Don't hardcode the range (allow consumers to customize min/max/increment if needed, but provide sensible defaults from project.md)
  </action>
  <verify>
TypeScript compiles with no errors.
calculateHaySensitivity returns array with correct number of points (default: 5 points from $40-$80).
Each point shows decreasing winterNetPerHead as hayPrice increases (inverse relationship).
totalFeedCost increases as hay price increases.
  </verify>
  <done>
HaySensitivityPoint and HaySensitivityTable types added.
calculateHaySensitivity function implemented with configurable range.
Default range matches project.md spec ($40-$80 in $10 increments).
Results ready for line chart generation in Phase 7.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement purchase price sensitivity and worst-case scenario</name>
  <files>src/lib/calculations.ts, src/lib/types.ts</files>
  <action>
Add purchase price sensitivity and worst-case scenario calculations.

**Add types to src/lib/types.ts:**

```typescript
export interface PurchaseSensitivityPoint {
  purchasePriceCwt: number;
  springNetPerHead: number;
  winterNetPerHead: number;
  annualNetTotal: number;
}

export type PurchaseSensitivityTable = PurchaseSensitivityPoint[];

export interface WorstCaseScenario {
  purchasePriceCwt: number;
  salePriceCwt: number;
  springNet: number;
  winterNet: number;
  annualNet: number;
  description: string;
}
```

**Add to src/lib/calculations.ts:**

```typescript
/**
 * Calculate purchase price sensitivity for both turns.
 * Shows how profitability changes across purchase price range.
 * Default range: base price ± $0.20/lb in $0.10 increments (from project.md).
 */
export function calculatePurchaseSensitivity(
  config: PlanConfig,
  rangePerLb: number = 0.20,
  incrementPerLb: number = 0.10
): PurchaseSensitivityTable {
  const results: PurchaseSensitivityTable = [];
  const headCount = config.head_count;
  const basePriceCwt = config.market_price_500lb;

  // Convert lb to cwt for iteration (range ±$20 per cwt if ±$0.20/lb)
  const rangeCwt = rangePerLb * 100;
  const incrementCwt = incrementPerLb * 100;

  const minPrice = basePriceCwt - rangeCwt;
  const maxPrice = basePriceCwt + rangeCwt;

  for (let purchasePrice = minPrice; purchasePrice <= maxPrice; purchasePrice += incrementCwt) {
    // Create modified config with custom purchase price
    const modifiedConfig = {
      ...config,
      market_price_500lb: purchasePrice,
    };

    // Recalculate both turns with modified purchase price
    const springResult = calculateSpringTurn(modifiedConfig);
    const winterResult = calculateWinterTurn(modifiedConfig);
    const annualNet = (springResult.netIncome * headCount) + (winterResult.netIncome * headCount);

    results.push({
      purchasePriceCwt: purchasePrice,
      springNetPerHead: springResult.netIncome,
      winterNetPerHead: winterResult.netIncome,
      annualNetTotal: annualNet,
    });
  }

  return results;
}

/**
 * Calculate worst-case scenario: highest purchase price + lowest sale price.
 */
export function calculateWorstCase(config: PlanConfig): WorstCaseScenario {
  const headCount = config.head_count;

  // Worst case: max purchase price (base + $0.20/lb = base + $20/cwt) + min sale price
  const worstConfig = {
    ...config,
    market_price_500lb: config.market_price_500lb + 20,  // +$0.20/lb
    market_price_850lb: config.sale_price_low_per_cwt,   // lowest sale price
  };

  const springWorst = calculateSpringTurn(worstConfig);
  const winterWorst = calculateWinterTurn(worstConfig);
  const annualNet = (springWorst.netIncome * headCount) + (winterWorst.netIncome * headCount);

  return {
    purchasePriceCwt: worstConfig.market_price_500lb,
    salePriceCwt: worstConfig.market_price_850lb,
    springNet: springWorst.netIncome,
    winterNet: winterWorst.netIncome,
    annualNet,
    description: 'Highest purchase price (+$0.20/lb) with lowest sale price scenario',
  };
}
```

**Export all new functions:**

```typescript
export {
  // ... existing exports
  calculateScenarios,
  calculateHaySensitivity,
  calculatePurchaseSensitivity,
  calculateWorstCase,
};
```

**What to avoid:**
- Don't confuse per-lb vs per-cwt prices (market_price_500lb is per cwt, so $0.20/lb = $20/cwt)
- Don't skip edge cases in sensitivity range (include both min and max endpoints)
- Don't calculate worst-case with unrealistic assumptions (use documented ±$0.20/lb range)
- Don't forget to export all new functions
  </action>
  <verify>
TypeScript compiles with no errors.
calculatePurchaseSensitivity returns 5 points (base ± $20/cwt in $10 increments).
Higher purchase prices show lower net income (inverse relationship).
calculateWorstCase shows most pessimistic scenario (should be negative or minimal profit).
All new functions are exported and usable.
  </verify>
  <done>
PurchaseSensitivityPoint, PurchaseSensitivityTable, and WorstCaseScenario types added.
calculatePurchaseSensitivity implemented with configurable range.
calculateWorstCase implemented showing highest cost + lowest revenue scenario.
All sensitivity functions ready for chart generation in Phase 7.
Phase 5 complete - full calculation engine ready for integration.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compilation succeeds with no errors
- [ ] calculateScenarios returns low/mid/high projections
- [ ] Scenario results match expected price/profit relationships
- [ ] calculateHaySensitivity produces table with 5 default points
- [ ] Hay sensitivity shows inverse relationship (higher hay = lower profit)
- [ ] calculatePurchaseSensitivity produces table with 5 default points
- [ ] Purchase sensitivity shows inverse relationship (higher purchase = lower profit)
- [ ] calculateWorstCase combines max costs with min revenue
- [ ] All functions are exported and importable
- [ ] All types exported from types.ts
</verification>

<success_criteria>

- All tasks completed
- Scenario analysis calculates low/mid/high price projections
- Hay price sensitivity function generates table for chart
- Purchase price sensitivity function generates table for chart
- Worst-case scenario calculation implemented
- All functions reuse core turn calculations (no duplication)
- All functions are pure, typed, and consistent with established patterns
- Phase 5 complete - calculation engine ready for Phase 6 (public plan pages) and Phase 7 (charts)
</success_criteria>

<output>
After completion, create `.planning/phases/05-financial-calculations/05-03-SUMMARY.md`:

# Phase 5 Plan 03: Scenario & Sensitivity Analysis Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `src/lib/calculations.ts` - Description
- `src/lib/types.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

**Phase 5 complete! Ready for Phase 6: Public Plan Pages**

Calculation engine provides:
- mergeConfig for override handling
- calculateSpringTurn and calculateWinterTurn for base projections
- calculateAnnualProjections for combined results
- calculateBreakeven for price analysis
- calculateScenarios for low/mid/high projections
- calculateHaySensitivity for feed cost analysis
- calculatePurchaseSensitivity for purchase price analysis
- calculateWorstCase for risk assessment

All functions typed, tested, and ready for use in public plan rendering (Phase 6) and chart generation (Phase 7).

No blockers for Phase 6 work.
</output>
